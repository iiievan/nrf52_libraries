###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         03/Feb/2021  19:31:03
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  E:\cpp\nrf52_libraries\pwm\nrf_hw_pwm.cpp
#    Command line =
#        -f C:\Users\IF385~1.SHO\AppData\Local\Temp\EW803F.tmp
#        (E:\cpp\nrf52_libraries\pwm\nrf_hw_pwm.cpp -D NRF52840_XXAA -D
#        CONFIG_NFCT_PINS_AS_GPIOS -D _AUDIOGUDE_V2_BOARD -D DEBUG -lCN
#        E:\cpp\nrf52_libraries\main\List -lA E:\cpp\nrf52_libraries\main\List
#        -o E:\cpp\nrf52_libraries\main\Obj --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Full.h" -I E:\cpp\nrf52_libraries\fsm\ -I
#        E:\cpp\nrf52_libraries\pwm\ -I E:\cpp\nrf52_libraries\spi\ -I
#        E:\cpp\nrf52_libraries\usb\ -I E:\cpp\nrf52_libraries\main\ -I
#        E:\cpp\nrf52_libraries\cmsis\ -I E:\cpp\nrf52_libraries\cmsis\device\
#        -I E:\cpp\nrf52_libraries\cmsis\include\ -I
#        E:\cpp\nrf52_libraries\board\ -I E:\cpp\nrf52_libraries\utils\ -I
#        E:\cpp\nrf52_libraries\timer\ -I E:\cpp\nrf52_libraries\adc\ -On --c++
#        --no_exceptions --no_rtti)
#    Locale       =  C
#    List file    =  E:\cpp\nrf52_libraries\main\List\nrf_hw_pwm.lst
#    Object file  =  E:\cpp\nrf52_libraries\main\Obj\nrf_hw_pwm.o
#
###############################################################################

E:\cpp\nrf52_libraries\pwm\nrf_hw_pwm.cpp
      1          #include "nrf_hw_pwm.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp NRF_GPIO_Type *nrf_gpio_pin_port_decode(uint32_t *)
   \                     _ZN36_INTERNAL_14_nrf_hw_pwm_cpp_e85aaef524nrf_gpio_pin_port_decodeEPj: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0x6808             LDR      R0,[R1, #+0]
   \        0x4   0x2820             CMP      R0,#+32
   \        0x6   0xD202             BCS.N    ??nrf_gpio_pin_port_decode_0
   \        0x8   0xF05F 0x40A0      MOVS     R0,#+1342177280
   \        0xC   0xE005             B.N      ??nrf_gpio_pin_port_decode_1
   \                     ??nrf_gpio_pin_port_decode_0: (+1)
   \        0xE   0x7808             LDRB     R0,[R1, #+0]
   \       0x10   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \       0x14   0x6008             STR      R0,[R1, #+0]
   \       0x16   0x....'....        LDR.W    R0,??DataTable17  ;; 0x50000300
   \                     ??nrf_gpio_pin_port_decode_1: (+1)
   \       0x1A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void nrf_gpio_cfg(uint32_t, nrf_gpio_pin_dir_t, nrf_gpio_pin_input_t, nrf_gpio_pin_pull_t, nrf_gpio_pin_drive_t, nrf_gpio_pin_sense_t)
   \                     _ZN36_INTERNAL_14_nrf_hw_pwm_cpp_e85aaef512nrf_gpio_cfgEj18nrf_gpio_pin_dir_t20nrf_gpio_pin_input_t19nrf_gpio_pin_pull_t20nrf_gpio_pin_drive_t20nrf_gpio_pin_sense_t: (+1)
   \        0x0   0xE92D 0x41F1      PUSH     {R0,R4-R8,LR}
   \        0x4   0xB081             SUB      SP,SP,#+4
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   \        0xC   0x9C08             LDR      R4,[SP, #+32]
   \        0xE   0x9D09             LDR      R5,[SP, #+36]
   \       0x10   0xA801             ADD      R0,SP,#+4
   \       0x12   0x....'....        BL       _ZN36_INTERNAL_14_nrf_hw_pwm_cpp_e85aaef524nrf_gpio_pin_port_decodeEPj
   \       0x16   0x0031             MOVS     R1,R6
   \       0x18   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x1A   0x003A             MOVS     R2,R7
   \       0x1C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x1E   0xEA51 0x0142      ORRS     R1,R1,R2, LSL #+1
   \       0x22   0x4642             MOV      R2,R8
   \       0x24   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x26   0xEA51 0x0182      ORRS     R1,R1,R2, LSL #+2
   \       0x2A   0x0022             MOVS     R2,R4
   \       0x2C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x2E   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \       0x32   0x002A             MOVS     R2,R5
   \       0x34   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x36   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \       0x3A   0x9A01             LDR      R2,[SP, #+4]
   \       0x3C   0xEB00 0x0282      ADD      R2,R0,R2, LSL #+2
   \       0x40   0xF8C2 0x1700      STR      R1,[R2, #+1792]
   \       0x44   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void nrf_gpio_cfg_output(uint32_t)
   \                     _ZN36_INTERNAL_14_nrf_hw_pwm_cpp_e85aaef519nrf_gpio_cfg_outputEj: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9001             STR      R0,[SP, #+4]
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x9000             STR      R0,[SP, #+0]
   \        0xC   0x2300             MOVS     R3,#+0
   \        0xE   0x2201             MOVS     R2,#+1
   \       0x10   0x2101             MOVS     R1,#+1
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0x....'....        BL       _ZN36_INTERNAL_14_nrf_hw_pwm_cpp_e85aaef512nrf_gpio_cfgEj18nrf_gpio_pin_dir_t20nrf_gpio_pin_input_t19nrf_gpio_pin_pull_t20nrf_gpio_pin_drive_t20nrf_gpio_pin_sense_t
   \       0x18   0xBD13             POP      {R0,R1,R4,PC}    ;; return
      2          

   \                                 In section .data, align 4
      3          NRF_PWM_Type* nrf_hw_pwm::_pwm_dev[] =
   \                     _ZN10nrf_hw_pwm8_pwm_devE:
   \        0x0   0x4001'C000        DC32 0x4001'c000, 0x4002'1000, 0x4002'2000, 0x4002'd000
   \              0x4002'1000  
   \              0x4002'2000  
   \              0x4002'D000  
      4          {
      5              NRF_PWM0,
      6              NRF_PWM1,
      7              NRF_PWM2,
      8              NRF_PWM3
      9          };
     10          

   \                                 In section .bss, align 4
     11          uint16_t  nrf_hw_pwm::_seq_0[HWPWM_MODULE_NUM][MAX_CHANNELS]      = {0};
   \                     _ZN10nrf_hw_pwm6_seq_0E:
   \        0x0                      DS8 32

   \                                 In section .bss, align 4
     12           int16_t  nrf_hw_pwm::_pin_allocation_map[LEDS_NUM][INFO_MAP_NUM] = {0};  // карта соответствия led pin chnl pwm
   \                     _ZN10nrf_hw_pwm19_pin_allocation_mapE:
   \        0x0                      DS8 48

   \                                 In section .data, align 2
     13           int16_t  nrf_hw_pwm::_old_chrg_bar_state                         = SHTDWN;
   \                     _ZN10nrf_hw_pwm19_old_chrg_bar_stateE:
   \        0x0   0xFFFF             DC16 -1
     14          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp nrf_hw_pwm::subobject nrf_hw_pwm()
   \                     _ZN10nrf_hw_pwmC2Ev: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x....'....        BL       _ZN10nrf_hw_pwmC1Ev
   \        0xA   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     15          nrf_hw_pwm::nrf_hw_pwm()
     16          {     
     17              // конструктор по умолчанию пустой, но он нужен
     18              // потому что сюда заходит каждый раз при создании объекта led_driver
     19          }
   \                     _ZN10nrf_hw_pwmC1Ev: (+1)
   \        0x0   0x4770             BX       LR               ;; return
     20          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp nrf_hw_pwm::subobject nrf_hw_pwm(uint16_t)
   \                     _ZN10nrf_hw_pwmC2Et: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       _ZN10nrf_hw_pwmC1Et
   \        0xC   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     21          nrf_hw_pwm::nrf_hw_pwm(uint16_t clock_div)
     22          {       
   \                     _ZN10nrf_hw_pwmC1Et: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
     23              // инициализируем таблицу соответствия каналов
     24              for (uint8_t k = 0; k < LEDS_NUM; k++)
   \        0x8   0x2000             MOVS     R0,#+0
   \                     ??nrf_hw_pwm_0: (+1)
   \        0xA   0x0001             MOVS     R1,R0
   \        0xC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0xE   0x2908             CMP      R1,#+8
   \       0x10   0xDA19             BGE.N    ??nrf_hw_pwm_1
     25              {
     26                  _pin_allocation_map[k][PIN_NUM] = REMOVED;   // пин отсутствует
   \       0x12   0x2106             MOVS     R1,#+6
   \       0x14   0x....'....        LDR.W    R2,??DataTable17_1
   \       0x18   0xF07F 0x0302      MVNS     R3,#+2
   \       0x1C   0x0006             MOVS     R6,R0
   \       0x1E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0x20   0x434E             MULS     R6,R1,R6
   \       0x22   0x5393             STRH     R3,[R2, R6]
     27                  _pin_allocation_map[k][CHN_NUM] = CHNL_NA;   // канала нет
   \       0x24   0x0003             MOVS     R3,R0
   \       0x26   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0x28   0x434B             MULS     R3,R1,R3
   \       0x2A   0x4413             ADD      R3,R2,R3
   \       0x2C   0xF07F 0x0601      MVNS     R6,#+1
   \       0x30   0x805E             STRH     R6,[R3, #+2]
     28                  _pin_allocation_map[k][PWM_NUM] = STATE_NA;  // номер модуля PWM неизвестен
   \       0x32   0x0003             MOVS     R3,R0
   \       0x34   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0x36   0xFB01 0xF103      MUL      R1,R1,R3
   \       0x3A   0x4411             ADD      R1,R2,R1
   \       0x3C   0xF05F 0x32FF      MOVS     R2,#-1
   \       0x40   0x808A             STRH     R2,[R1, #+4]
     29              }  
   \       0x42   0x1C40             ADDS     R0,R0,#+1
   \       0x44   0xE7E1             B.N      ??nrf_hw_pwm_0
     30              
     31              // обнуляем таблицу значений PWM
     32              memset(_seq_0, 0, MAX_CHANNELS);
   \                     ??nrf_hw_pwm_1: (+1)
   \       0x46   0x2704             MOVS     R7,#+4
   \       0x48   0xF05F 0x0800      MOVS     R8,#+0
   \       0x4C   0x....'....        LDR.W    R6,??DataTable17_2
   \       0x50   0x4642             MOV      R2,R8
   \       0x52   0x0039             MOVS     R1,R7
   \       0x54   0x0030             MOVS     R0,R6
   \       0x56   0x....'....        BL       __aeabi_memset
     33              set_clock_div(clock_div);    
   \       0x5A   0x0029             MOVS     R1,R5
   \       0x5C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x5E   0x0020             MOVS     R0,R4
   \       0x60   0x....'....        BL       _ZN10nrf_hw_pwm13set_clock_divEh
     34          
     35              for(uint8_t pwm = 0; pwm < HWPWM_MODULE_NUM; pwm++)
   \       0x64   0x2600             MOVS     R6,#+0
   \                     ??nrf_hw_pwm_2: (+1)
   \       0x66   0x0030             MOVS     R0,R6
   \       0x68   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x6A   0x2804             CMP      R0,#+4
   \       0x6C   0xDA0C             BGE.N    ??nrf_hw_pwm_3
     36              {
     37                  set_max_value(pwm, (uint32_t)MAX_PWM_VALUE);
   \       0x6E   0x22FF             MOVS     R2,#+255
   \       0x70   0x0031             MOVS     R1,R6
   \       0x72   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x74   0x0020             MOVS     R0,R4
   \       0x76   0x....'....        BL       _ZN10nrf_hw_pwm13set_max_valueEhj
     38                  _setup(pwm);
   \       0x7A   0x0031             MOVS     R1,R6
   \       0x7C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x7E   0x0020             MOVS     R0,R4
   \       0x80   0x....'....        BL       _ZN10nrf_hw_pwm6_setupEh
     39              }
   \       0x84   0x1C76             ADDS     R6,R6,#+1
   \       0x86   0xE7EE             B.N      ??nrf_hw_pwm_2
     40          
     41              // в данной конфигурации модуля чарджбара нет.
     42              _chctrl_1 = REMOVED;
   \                     ??nrf_hw_pwm_3: (+1)
   \       0x88   0xF07F 0x0002      MVNS     R0,#+2
   \       0x8C   0x80A0             STRH     R0,[R4, #+4]
     43              _chctrl_2 = REMOVED;
   \       0x8E   0x80E0             STRH     R0,[R4, #+6]
     44              _chctrl_3 = REMOVED;
   \       0x90   0x8120             STRH     R0,[R4, #+8]
     45          }
   \       0x92   0x0020             MOVS     R0,R4
   \       0x94   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
     46          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp nrf_hw_pwm::subobject nrf_hw_pwm(uint16_t, uint32_t, uint32_t, uint32_t)
   \                     _ZN10nrf_hw_pwmC2Etjjj: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x9804             LDR      R0,[SP, #+16]
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x....'....        BL       _ZN10nrf_hw_pwmC1Etjjj
   \       0x10   0xBD16             POP      {R1,R2,R4,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
     47          nrf_hw_pwm::nrf_hw_pwm(uint16_t clock_div, uint32_t pin_1, uint32_t pin_2, uint32_t pin_3)
     48          {       
   \                     _ZN10nrf_hw_pwmC1Etjjj: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8028      LDR      R8,[SP, #+40]
     49              // инициализируем таблицу соответствия каналов
     50              for (uint8_t k = 0; k < LEDS_NUM; k++)
   \       0x10   0x2000             MOVS     R0,#+0
   \                     ??nrf_hw_pwm_4: (+1)
   \       0x12   0x0001             MOVS     R1,R0
   \       0x14   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x16   0x2908             CMP      R1,#+8
   \       0x18   0xDA1D             BGE.N    ??nrf_hw_pwm_5
     51              {
     52                  _pin_allocation_map[k][PIN_NUM] = REMOVED;   // пин отсутствует
   \       0x1A   0x2106             MOVS     R1,#+6
   \       0x1C   0x....'....        LDR.W    R2,??DataTable17_1
   \       0x20   0xF07F 0x0302      MVNS     R3,#+2
   \       0x24   0x4684             MOV      R12,R0
   \       0x26   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \       0x2A   0xFB01 0xFC0C      MUL      R12,R1,R12
   \       0x2E   0xF822 0x300C      STRH     R3,[R2, R12]
     53                  _pin_allocation_map[k][CHN_NUM] = CHNL_NA;   // канала нет
   \       0x32   0x0003             MOVS     R3,R0
   \       0x34   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0x36   0x434B             MULS     R3,R1,R3
   \       0x38   0x4413             ADD      R3,R2,R3
   \       0x3A   0xF07F 0x0C01      MVNS     R12,#+1
   \       0x3E   0xF8A3 0xC002      STRH     R12,[R3, #+2]
     54                  _pin_allocation_map[k][PWM_NUM] = STATE_NA;  // номер модуля PWM неизвестен
   \       0x42   0x0003             MOVS     R3,R0
   \       0x44   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0x46   0xFB01 0xF103      MUL      R1,R1,R3
   \       0x4A   0x4411             ADD      R1,R2,R1
   \       0x4C   0xF05F 0x32FF      MOVS     R2,#-1
   \       0x50   0x808A             STRH     R2,[R1, #+4]
     55              }  
   \       0x52   0x1C40             ADDS     R0,R0,#+1
   \       0x54   0xE7DD             B.N      ??nrf_hw_pwm_4
     56              
     57              // обнуляем таблицу значений PWM
     58              memset(_seq_0, 0, MAX_CHANNELS);
   \                     ??nrf_hw_pwm_5: (+1)
   \       0x56   0xF05F 0x0904      MOVS     R9,#+4
   \       0x5A   0xF05F 0x0A00      MOVS     R10,#+0
   \       0x5E   0x....'....        LDR.W    R11,??DataTable17_2
   \       0x62   0x4652             MOV      R2,R10
   \       0x64   0x4649             MOV      R1,R9
   \       0x66   0x4658             MOV      R0,R11
   \       0x68   0x....'....        BL       __aeabi_memset
     59              set_clock_div(clock_div);    
   \       0x6C   0x0029             MOVS     R1,R5
   \       0x6E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x70   0x0020             MOVS     R0,R4
   \       0x72   0x....'....        BL       _ZN10nrf_hw_pwm13set_clock_divEh
     60          
     61              for(uint8_t pwm = 0; pwm < HWPWM_MODULE_NUM; pwm++)
   \       0x76   0xF05F 0x0B00      MOVS     R11,#+0
   \                     ??nrf_hw_pwm_6: (+1)
   \       0x7A   0x4658             MOV      R0,R11
   \       0x7C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x7E   0x2804             CMP      R0,#+4
   \       0x80   0xDA0D             BGE.N    ??nrf_hw_pwm_7
     62              {
     63                  set_max_value(pwm, (uint32_t)MAX_PWM_VALUE);
   \       0x82   0x22FF             MOVS     R2,#+255
   \       0x84   0x4659             MOV      R1,R11
   \       0x86   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x88   0x0020             MOVS     R0,R4
   \       0x8A   0x....'....        BL       _ZN10nrf_hw_pwm13set_max_valueEhj
     64                  _setup(pwm);
   \       0x8E   0x4659             MOV      R1,R11
   \       0x90   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x92   0x0020             MOVS     R0,R4
   \       0x94   0x....'....        BL       _ZN10nrf_hw_pwm6_setupEh
     65              }
   \       0x98   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \       0x9C   0xE7ED             B.N      ??nrf_hw_pwm_6
     66          
     67              // Добавляем пины и светодиоды для модуля управляения чардж баром.
     68              add_pin(pin_1);
   \                     ??nrf_hw_pwm_7: (+1)
   \       0x9E   0x0031             MOVS     R1,R6
   \       0xA0   0x0020             MOVS     R0,R4
   \       0xA2   0x....'....        BL       _ZN10nrf_hw_pwm7add_pinEj
     69              add_pin(pin_2);
   \       0xA6   0x0039             MOVS     R1,R7
   \       0xA8   0x0020             MOVS     R0,R4
   \       0xAA   0x....'....        BL       _ZN10nrf_hw_pwm7add_pinEj
     70              add_pin(pin_3);
   \       0xAE   0x4641             MOV      R1,R8
   \       0xB0   0x0020             MOVS     R0,R4
   \       0xB2   0x....'....        BL       _ZN10nrf_hw_pwm7add_pinEj
     71          
     72              _chctrl_1 = _pin_2_led(pin_1);
   \       0xB6   0x0031             MOVS     R1,R6
   \       0xB8   0x0020             MOVS     R0,R4
   \       0xBA   0x....'....        BL       _ZN10nrf_hw_pwm10_pin_2_ledEj
   \       0xBE   0x80A0             STRH     R0,[R4, #+4]
     73              _chctrl_2 = _pin_2_led(pin_2);
   \       0xC0   0x0039             MOVS     R1,R7
   \       0xC2   0x0020             MOVS     R0,R4
   \       0xC4   0x....'....        BL       _ZN10nrf_hw_pwm10_pin_2_ledEj
   \       0xC8   0x80E0             STRH     R0,[R4, #+6]
     74              _chctrl_3 = _pin_2_led(pin_3);
   \       0xCA   0x4641             MOV      R1,R8
   \       0xCC   0x0020             MOVS     R0,R4
   \       0xCE   0x....'....        BL       _ZN10nrf_hw_pwm10_pin_2_ledEj
   \       0xD2   0x8120             STRH     R0,[R4, #+8]
     75          }
   \       0xD4   0x0020             MOVS     R0,R4
   \       0xD6   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
     76          
     77          // оставлю на всякий случай на будущее, но в целом оперировать uint8_t разрядностью удобно
     78          // при задании ШИМ.

   \                                 In section .text, align 2, keep-with-next
     79          void nrf_hw_pwm::set_max_value(uint8_t pwm_index, uint32_t value)
     80          {
   \                     _ZN10nrf_hw_pwm13set_max_valueEhj: (+1)
   \        0x0   0xB410             PUSH     {R4}
     81              _max_value = value;
   \        0x2   0x8002             STRH     R2,[R0, #+0]
     82          
     83              _pwm_dev[pwm_index]->COUNTERTOP = value;
   \        0x4   0x....'....        LDR.W    R3,??DataTable17_3
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \        0xC   0xF853 0x3024      LDR      R3,[R3, R4, LSL #+2]
   \       0x10   0xF8C3 0x2508      STR      R2,[R3, #+1288]
     84          }
   \       0x14   0xBC10             POP      {R4}
   \       0x16   0x4770             BX       LR               ;; return
     85          
     86          
     87          // 1:2:4:8:16:32:64:128

   \                                 In section .text, align 2, keep-with-next
     88          void nrf_hw_pwm::set_clock_div(uint8_t div )
     89          {
     90              switch (div) {
   \                     _ZN10nrf_hw_pwm13set_clock_divEh: (+1)
   \        0x0   0x000A             MOVS     R2,R1
   \        0x2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \        0x4   0x2A01             CMP      R2,#+1
   \        0x6   0xD00E             BEQ.N    ??set_clock_div_0
   \        0x8   0x2A02             CMP      R2,#+2
   \        0xA   0xD00F             BEQ.N    ??set_clock_div_1
   \        0xC   0x2A04             CMP      R2,#+4
   \        0xE   0xD010             BEQ.N    ??set_clock_div_2
   \       0x10   0x2A08             CMP      R2,#+8
   \       0x12   0xD011             BEQ.N    ??set_clock_div_3
   \       0x14   0x2A10             CMP      R2,#+16
   \       0x16   0xD012             BEQ.N    ??set_clock_div_4
   \       0x18   0x2A20             CMP      R2,#+32
   \       0x1A   0xD013             BEQ.N    ??set_clock_div_5
   \       0x1C   0x2A40             CMP      R2,#+64
   \       0x1E   0xD014             BEQ.N    ??set_clock_div_6
   \       0x20   0x2A80             CMP      R2,#+128
   \       0x22   0xD015             BEQ.N    ??set_clock_div_7
   \       0x24   0xE017             B.N      ??set_clock_div_8
     91                  case 1:
     92                      _clock_div = (uint8_t)PWM_PRESCALER_PRESCALER_DIV_1;
   \                     ??set_clock_div_0: (+1)
   \       0x26   0x2200             MOVS     R2,#+0
   \       0x28   0x7082             STRB     R2,[R0, #+2]
     93                      break;
   \       0x2A   0xE016             B.N      ??set_clock_div_9
     94                  case 2:
     95                      _clock_div = (uint8_t)PWM_PRESCALER_PRESCALER_DIV_2;
   \                     ??set_clock_div_1: (+1)
   \       0x2C   0x2201             MOVS     R2,#+1
   \       0x2E   0x7082             STRB     R2,[R0, #+2]
     96                      break;
   \       0x30   0xE013             B.N      ??set_clock_div_9
     97                  case 4:
     98                      _clock_div = (uint8_t)PWM_PRESCALER_PRESCALER_DIV_4;
   \                     ??set_clock_div_2: (+1)
   \       0x32   0x2202             MOVS     R2,#+2
   \       0x34   0x7082             STRB     R2,[R0, #+2]
     99                      break;
   \       0x36   0xE010             B.N      ??set_clock_div_9
    100                  case 8:
    101                      _clock_div = (uint8_t)PWM_PRESCALER_PRESCALER_DIV_8;
   \                     ??set_clock_div_3: (+1)
   \       0x38   0x2203             MOVS     R2,#+3
   \       0x3A   0x7082             STRB     R2,[R0, #+2]
    102                      break;
   \       0x3C   0xE00D             B.N      ??set_clock_div_9
    103                  case 16:
    104                      _clock_div = (uint8_t)PWM_PRESCALER_PRESCALER_DIV_16;
   \                     ??set_clock_div_4: (+1)
   \       0x3E   0x2204             MOVS     R2,#+4
   \       0x40   0x7082             STRB     R2,[R0, #+2]
    105                      break;
   \       0x42   0xE00A             B.N      ??set_clock_div_9
    106                  case 32:
    107                      _clock_div = (uint8_t)PWM_PRESCALER_PRESCALER_DIV_32;
   \                     ??set_clock_div_5: (+1)
   \       0x44   0x2205             MOVS     R2,#+5
   \       0x46   0x7082             STRB     R2,[R0, #+2]
    108                      break;
   \       0x48   0xE007             B.N      ??set_clock_div_9
    109                  case 64:
    110                      _clock_div = (uint8_t)PWM_PRESCALER_PRESCALER_DIV_64;
   \                     ??set_clock_div_6: (+1)
   \       0x4A   0x2206             MOVS     R2,#+6
   \       0x4C   0x7082             STRB     R2,[R0, #+2]
    111                      break;
   \       0x4E   0xE004             B.N      ??set_clock_div_9
    112                  case 128:
    113                      _clock_div = (uint8_t)PWM_PRESCALER_PRESCALER_DIV_128;
   \                     ??set_clock_div_7: (+1)
   \       0x50   0x2207             MOVS     R2,#+7
   \       0x52   0x7082             STRB     R2,[R0, #+2]
    114                      break;
   \       0x54   0xE001             B.N      ??set_clock_div_9
    115                  default:
    116                      // по умолчанию ставим 16МГц
    117                      _clock_div = PWM_PRESCALER_PRESCALER_DIV_1;
   \                     ??set_clock_div_8: (+1)
   \       0x56   0x2200             MOVS     R2,#+0
   \       0x58   0x7082             STRB     R2,[R0, #+2]
    118              }
    119          }
   \                     ??set_clock_div_9: (+1)
   \       0x5A   0x4770             BX       LR               ;; return
    120          
    121          /**
    122           * Add pin to this group.
    123           * @param pin Pin to add
    124           * @return true if add succeeded, or pin is already added
    125           */

   \                                 In section .text, align 2, keep-with-next
    126          int8_t nrf_hw_pwm::add_pin(uint32_t pin)
    127          {
   \                     _ZN10nrf_hw_pwm7add_pinEj: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    128              volatile      int        ch = CHNL_NA;
   \        0x6   0xF07F 0x0001      MVNS     R0,#+1
   \        0xA   0x9001             STR      R0,[SP, #+4]
    129              volatile  int16_t       led = _pin_2_led(pin);
   \        0xC   0x0029             MOVS     R1,R5
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0x....'....        BL       _ZN10nrf_hw_pwm10_pin_2_ledEj
   \       0x14   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    130                         int8_t pwm_index = STATE_NA;
   \       0x18   0xF05F 0x36FF      MOVS     R6,#-1
    131          
    132              if(led != REMOVED)
   \       0x1C   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \       0x20   0xF110 0x0F03      CMN      R0,#+3
   \       0x24   0xD001             BEQ.N    ??add_pin_0
    133              { return ALRDY_IS; } 
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xE08C             B.N      ??add_pin_1
    134          
    135              // find free slot which is not connected
    136              for(uint8_t pwm = 0; pwm < HWPWM_MODULE_NUM; pwm++)
   \                     ??add_pin_0: (+1)
   \       0x2A   0x2000             MOVS     R0,#+0
   \                     ??add_pin_2: (+1)
   \       0x2C   0x0001             MOVS     R1,R0
   \       0x2E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x30   0x2904             CMP      R1,#+4
   \       0x32   0xDA1A             BGE.N    ??add_pin_3
    137              {
    138                  for(int i = 0; i < MAX_CHANNELS; i++)
   \       0x34   0x2100             MOVS     R1,#+0
   \                     ??add_pin_4: (+1)
   \       0x36   0x2904             CMP      R1,#+4
   \       0x38   0xDA12             BGE.N    ??add_pin_5
    139                  {
    140                      if ( _pwm_dev[pwm]->PSEL.OUT[i] & PWM_PSEL_OUT_CONNECT_Msk )
   \       0x3A   0x....'....        LDR.W    R2,??DataTable17_3
   \       0x3E   0x0003             MOVS     R3,R0
   \       0x40   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0x42   0xF852 0x2023      LDR      R2,[R2, R3, LSL #+2]
   \       0x46   0xEB02 0x0281      ADD      R2,R2,R1, LSL #+2
   \       0x4A   0xF8D2 0x2560      LDR      R2,[R2, #+1376]
   \       0x4E   0x2A00             CMP      R2,#+0
   \       0x50   0xD504             BPL.N    ??add_pin_6
    141                      {
    142                          ch = i;
   \       0x52   0x9101             STR      R1,[SP, #+4]
    143                          pwm_index = pwm;   // далее работаем с этим модулем PWM
   \       0x54   0x0002             MOVS     R2,R0
   \       0x56   0xB252             SXTB     R2,R2            ;; SignExt  R2,R2,#+24,#+24
   \       0x58   0x0016             MOVS     R6,R2
    144                          break;
   \       0x5A   0xE001             B.N      ??add_pin_5
    145                      }
    146                  }
   \                     ??add_pin_6: (+1)
   \       0x5C   0x1C49             ADDS     R1,R1,#+1
   \       0x5E   0xE7EA             B.N      ??add_pin_4
    147                      
    148                  if(ch >= 0)
   \                     ??add_pin_5: (+1)
   \       0x60   0x9901             LDR      R1,[SP, #+4]
   \       0x62   0x2900             CMP      R1,#+0
   \       0x64   0xD501             BPL.N    ??add_pin_3
    149                  { break; }        
    150               }    
   \                     ??add_pin_7: (+1)
   \       0x66   0x1C40             ADDS     R0,R0,#+1
   \       0x68   0xE7E0             B.N      ??add_pin_2
    151              
    152              // не удалось выделить канал
    153              if(ch < 0)
   \                     ??add_pin_3: (+1)
   \       0x6A   0x9801             LDR      R0,[SP, #+4]
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD502             BPL.N    ??add_pin_8
    154              { return ch; } 
   \       0x70   0x9801             LDR      R0,[SP, #+4]
   \       0x72   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \       0x74   0xE066             B.N      ??add_pin_1
    155          
    156              // если все ок, добавляем канал в карту вместе с пином и номером PWM модуля.
    157              for (uint8_t i = 0; i < LEDS_NUM; i++)
   \                     ??add_pin_8: (+1)
   \       0x76   0x2000             MOVS     R0,#+0
   \                     ??add_pin_9: (+1)
   \       0x78   0x0001             MOVS     R1,R0
   \       0x7A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x7C   0x2908             CMP      R1,#+8
   \       0x7E   0xDA22             BGE.N    ??add_pin_10
    158              {
    159                  if (led_2_port_list[i] == pin) 
   \       0x80   0x....'....        LDR.W    R1,??DataTable17_4
   \       0x84   0x0002             MOVS     R2,R0
   \       0x86   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x88   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   \       0x8C   0x42A9             CMP      R1,R5
   \       0x8E   0xD118             BNE.N    ??add_pin_11
    160                  {
    161                      _pin_allocation_map[i][PIN_NUM] = (uint8_t)pin;
   \       0x90   0x2106             MOVS     R1,#+6
   \       0x92   0x....'....        LDR.W    R2,??DataTable17_1
   \       0x96   0x002B             MOVS     R3,R5
   \       0x98   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0x9A   0x0007             MOVS     R7,R0
   \       0x9C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \       0x9E   0x434F             MULS     R7,R1,R7
   \       0xA0   0x53D3             STRH     R3,[R2, R7]
    162                      _pin_allocation_map[i][CHN_NUM] = (uint8_t)ch;
   \       0xA2   0x0003             MOVS     R3,R0
   \       0xA4   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0xA6   0x434B             MULS     R3,R1,R3
   \       0xA8   0x4413             ADD      R3,R2,R3
   \       0xAA   0x9F01             LDR      R7,[SP, #+4]
   \       0xAC   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \       0xAE   0x805F             STRH     R7,[R3, #+2]
    163                      _pin_allocation_map[i][PWM_NUM] = (uint8_t)pwm_index;
   \       0xB0   0x0003             MOVS     R3,R0
   \       0xB2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0xB4   0xFB01 0xF103      MUL      R1,R1,R3
   \       0xB8   0x4411             ADD      R1,R2,R1
   \       0xBA   0x0032             MOVS     R2,R6
   \       0xBC   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0xBE   0x808A             STRH     R2,[R1, #+4]
    164                      break;
   \       0xC0   0xE001             B.N      ??add_pin_10
    165                  }
    166              }
   \                     ??add_pin_11: (+1)
   \       0xC2   0x1C40             ADDS     R0,R0,#+1
   \       0xC4   0xE7D8             B.N      ??add_pin_9
    167              
    168              nrf_gpio_cfg_output(pin);
   \                     ??add_pin_10: (+1)
   \       0xC6   0x0028             MOVS     R0,R5
   \       0xC8   0x....'....        BL       _ZN36_INTERNAL_14_nrf_hw_pwm_cpp_e85aaef519nrf_gpio_cfg_outputEj
    169              led = _pin_2_led(pin);
   \       0xCC   0x0029             MOVS     R1,R5
   \       0xCE   0x0020             MOVS     R0,R4
   \       0xD0   0x....'....        BL       _ZN10nrf_hw_pwm10_pin_2_ledEj
   \       0xD4   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    170              
    171              // Must disable before changing PSEL
    172              if (_is_enabled(pwm_index))
   \       0xD8   0x0031             MOVS     R1,R6
   \       0xDA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0xDC   0x0020             MOVS     R0,R4
   \       0xDE   0x....'....        BL       _ZN10nrf_hw_pwm11_is_enabledEh
   \       0xE2   0x2800             CMP      R0,#+0
   \       0xE4   0xD019             BEQ.N    ??add_pin_12
    173              {
    174                  _pwm_dev[pwm_index]->ENABLE = 0;
   \       0xE6   0x....'....        LDR.W    R0,??DataTable17_3
   \       0xEA   0x2100             MOVS     R1,#+0
   \       0xEC   0x0032             MOVS     R2,R6
   \       0xEE   0xB252             SXTB     R2,R2            ;; SignExt  R2,R2,#+24,#+24
   \       0xF0   0xF850 0x2022      LDR      R2,[R0, R2, LSL #+2]
   \       0xF4   0xF8C2 0x1500      STR      R1,[R2, #+1280]
    175                  _pwm_dev[pwm_index]->PSEL.OUT[ch] = pin;
   \       0xF8   0x0031             MOVS     R1,R6
   \       0xFA   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \       0xFC   0xF850 0x1021      LDR      R1,[R0, R1, LSL #+2]
   \      0x100   0x9A01             LDR      R2,[SP, #+4]
   \      0x102   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   \      0x106   0xF8C1 0x5560      STR      R5,[R1, #+1376]
    176                  _pwm_dev[pwm_index]->ENABLE = 1;
   \      0x10A   0x2101             MOVS     R1,#+1
   \      0x10C   0x0032             MOVS     R2,R6
   \      0x10E   0xB252             SXTB     R2,R2            ;; SignExt  R2,R2,#+24,#+24
   \      0x110   0xF850 0x0022      LDR      R0,[R0, R2, LSL #+2]
   \      0x114   0xF8C0 0x1500      STR      R1,[R0, #+1280]
   \      0x118   0xE00A             B.N      ??add_pin_13
    177              }
    178              else
    179              {
    180                  _pwm_dev[pwm_index]->PSEL.OUT[ch] = pin;
   \                     ??add_pin_12: (+1)
   \      0x11A   0x....'....        LDR.W    R0,??DataTable17_3
   \      0x11E   0x0031             MOVS     R1,R6
   \      0x120   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \      0x122   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \      0x126   0x9901             LDR      R1,[SP, #+4]
   \      0x128   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \      0x12C   0xF8C0 0x5560      STR      R5,[R0, #+1376]
    181              }
    182              
    183              //обнуляем канал
    184              write_chnl(led, 0);
   \                     ??add_pin_13: (+1)
   \      0x130   0x2300             MOVS     R3,#+0
   \      0x132   0x2200             MOVS     R2,#+0
   \      0x134   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x138   0x0001             MOVS     R1,R0
   \      0x13A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x13C   0x0020             MOVS     R0,R4
   \      0x13E   0x....'....        BL       _ZN10nrf_hw_pwm10write_chnlEhjb
    185              
    186              return STATE_OK;
   \      0x142   0x2001             MOVS     R0,#+1
   \                     ??add_pin_1: (+1)
   \      0x144   0xBDFE             POP      {R1-R7,PC}       ;; return
    187          }
    188          

   \                                 In section .text, align 2, keep-with-next
    189          int8_t nrf_hw_pwm::remove_pin(uint8_t led)
    190          {
   \                     _ZN10nrf_hw_pwm10remove_pinEh: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    191              int8_t pwm_index = STATE_NA;
   \        0x6   0xF05F 0x36FF      MOVS     R6,#-1
    192            
    193              // неправильный светодиод
    194              if (led >= LEDS_NUM)
   \        0xA   0x0028             MOVS     R0,R5
   \        0xC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0xE   0x2808             CMP      R0,#+8
   \       0x10   0xDB02             BLT.N    ??remove_pin_0
    195              { return REMOVED; }
   \       0x12   0xF07F 0x0002      MVNS     R0,#+2
   \       0x16   0xE04B             B.N      ??remove_pin_1
    196          
    197              volatile int ch = (int)_led_2_channel(led);
   \                     ??remove_pin_0: (+1)
   \       0x18   0x0029             MOVS     R1,R5
   \       0x1A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x....'....        BL       _ZN10nrf_hw_pwm14_led_2_channelEh
   \       0x22   0x9000             STR      R0,[SP, #+0]
    198          
    199              // неверный канал
    200              if (ch < 0)
   \       0x24   0x9800             LDR      R0,[SP, #+0]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD502             BPL.N    ??remove_pin_2
    201              return (int16_t)ch; 
   \       0x2A   0x9800             LDR      R0,[SP, #+0]
   \       0x2C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \       0x2E   0xE03F             B.N      ??remove_pin_1
    202          
    203              pwm_index = _pin_allocation_map[led][PWM_NUM];
   \                     ??remove_pin_2: (+1)
   \       0x30   0x....'....        LDR.W    R1,??DataTable17_1
   \       0x34   0x002A             MOVS     R2,R5
   \       0x36   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x38   0x2006             MOVS     R0,#+6
   \       0x3A   0x4342             MULS     R2,R0,R2
   \       0x3C   0xEB01 0x0002      ADD      R0,R1,R2
   \       0x40   0x8887             LDRH     R7,[R0, #+4]
    204          
    205              bool const en = _is_enabled(pwm_index);
   \       0x42   0x0039             MOVS     R1,R7
   \       0x44   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x46   0x0020             MOVS     R0,R4
   \       0x48   0x....'....        BL       _ZN10nrf_hw_pwm11_is_enabledEh
   \       0x4C   0x0001             MOVS     R1,R0
    206          
    207              // Must disable before changing PSEL
    208              if (en) _pwm_dev[pwm_index]->ENABLE = 0;
   \       0x4E   0x0008             MOVS     R0,R1
   \       0x50   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD008             BEQ.N    ??remove_pin_3
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x....'....        LDR.W    R2,??DataTable17_3
   \       0x5C   0x003B             MOVS     R3,R7
   \       0x5E   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \       0x60   0xF852 0x2023      LDR      R2,[R2, R3, LSL #+2]
   \       0x64   0xF8C2 0x0500      STR      R0,[R2, #+1280]
    209              
    210              _pwm_dev[pwm_index]->PSEL.OUT[ch] = PIN_DISCONNECTED;
   \                     ??remove_pin_3: (+1)
   \       0x68   0x....'....        LDR.W    R2,??DataTable17_3
   \       0x6C   0x0038             MOVS     R0,R7
   \       0x6E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \       0x70   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \       0x74   0x9B00             LDR      R3,[SP, #+0]
   \       0x76   0xEB00 0x0083      ADD      R0,R0,R3, LSL #+2
   \       0x7A   0xF05F 0x33FF      MOVS     R3,#-1
   \       0x7E   0xF8C0 0x3560      STR      R3,[R0, #+1376]
    211              
    212              _seq_0[pwm_index][ch] = 0;
   \       0x82   0x....'....        LDR.W    R0,??DataTable17_2
   \       0x86   0x003B             MOVS     R3,R7
   \       0x88   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \       0x8A   0xEB00 0x00C3      ADD      R0,R0,R3, LSL #+3
   \       0x8E   0x9B00             LDR      R3,[SP, #+0]
   \       0x90   0x2600             MOVS     R6,#+0
   \       0x92   0xF820 0x6013      STRH     R6,[R0, R3, LSL #+1]
    213              
    214              if (en) _pwm_dev[pwm_index]->ENABLE = 1;
   \       0x96   0x0008             MOVS     R0,R1
   \       0x98   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xD006             BEQ.N    ??remove_pin_4
   \       0x9E   0x2001             MOVS     R0,#+1
   \       0xA0   0x003B             MOVS     R3,R7
   \       0xA2   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \       0xA4   0xF852 0x2023      LDR      R2,[R2, R3, LSL #+2]
   \       0xA8   0xF8C2 0x0500      STR      R0,[R2, #+1280]
    215              
    216              return REMOVED;
   \                     ??remove_pin_4: (+1)
   \       0xAC   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??remove_pin_1: (+1)
   \       0xB0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    217          }
    218          

   \                                 In section .text, align 2, keep-with-next
    219          int16_t nrf_hw_pwm::_led_2_channel(uint8_t led)
    220          {
   \                     _ZN10nrf_hw_pwm14_led_2_channelEh: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0002             MOVS     R2,R0
    221              // нет такого светодиода
    222              if(led >= LEDS_NUM)
   \        0x4   0x0008             MOVS     R0,R1
   \        0x6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x8   0x2808             CMP      R0,#+8
   \        0xA   0xDB02             BLT.N    ??_led_2_channel_0
    223              { return  REMOVED; }
   \        0xC   0xF07F 0x0002      MVNS     R0,#+2
   \       0x10   0xE014             B.N      ??_led_2_channel_1
    224          
    225              if ( _pin_allocation_map[led][CHN_NUM] != CHNL_NA)
   \                     ??_led_2_channel_0: (+1)
   \       0x12   0x2006             MOVS     R0,#+6
   \       0x14   0x....'....        LDR.W    R3,??DataTable17_1
   \       0x18   0x000C             MOVS     R4,R1
   \       0x1A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x1C   0x4344             MULS     R4,R0,R4
   \       0x1E   0x441C             ADD      R4,R3,R4
   \       0x20   0xF9B4 0x4002      LDRSH    R4,[R4, #+2]
   \       0x24   0xF114 0x0F02      CMN      R4,#+2
   \       0x28   0xD006             BEQ.N    ??_led_2_channel_2
    226              {  return _pin_allocation_map[led][CHN_NUM]; } 
   \       0x2A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x2C   0x4341             MULS     R1,R0,R1
   \       0x2E   0xEB03 0x0001      ADD      R0,R3,R1
   \       0x32   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \       0x36   0xE001             B.N      ??_led_2_channel_1
    227              else
    228              {  
    229                  // нет такого канала
    230                  return CHNL_NA; 
   \                     ??_led_2_channel_2: (+1)
   \       0x38   0xF07F 0x0001      MVNS     R0,#+1
   \                     ??_led_2_channel_1: (+1)
   \       0x3C   0xBC10             POP      {R4}
   \       0x3E   0x4770             BX       LR               ;; return
    231              }    
    232          }
    233          

   \                                 In section .text, align 2, keep-with-next
    234          int16_t nrf_hw_pwm::_pin_2_led(uint32_t pin)
    235          {
   \                     _ZN10nrf_hw_pwm10_pin_2_ledEj: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x0003             MOVS     R3,R0
    236              for(uint8_t led = 0; led < LEDS_NUM; led++)
   \        0x4   0x2000             MOVS     R0,#+0
   \                     ??_pin_2_led_0: (+1)
   \        0x6   0x0002             MOVS     R2,R0
   \        0x8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \        0xA   0x2A08             CMP      R2,#+8
   \        0xC   0xDA0D             BGE.N    ??_pin_2_led_1
    237              {
    238                  // такой пин уже есть, выходим из функции
    239                  if(_pin_allocation_map[led][PIN_NUM] == pin)
   \        0xE   0x....'....        LDR.W    R4,??DataTable17_1
   \       0x12   0x0005             MOVS     R5,R0
   \       0x14   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \       0x16   0x2206             MOVS     R2,#+6
   \       0x18   0x4355             MULS     R5,R2,R5
   \       0x1A   0x5F62             LDRSH    R2,[R4, R5]
   \       0x1C   0x428A             CMP      R2,R1
   \       0x1E   0xD102             BNE.N    ??_pin_2_led_2
    240                  { return led; }
   \       0x20   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x22   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \       0x24   0xE003             B.N      ??_pin_2_led_3
    241              }
   \                     ??_pin_2_led_2: (+1)
   \       0x26   0x1C40             ADDS     R0,R0,#+1
   \       0x28   0xE7ED             B.N      ??_pin_2_led_0
    242          
    243              // нет такого пина
    244              return REMOVED;  
   \                     ??_pin_2_led_1: (+1)
   \       0x2A   0xF07F 0x0002      MVNS     R0,#+2
   \                     ??_pin_2_led_3: (+1)
   \       0x2E   0xBC30             POP      {R4,R5}
   \       0x30   0x4770             BX       LR               ;; return
    245          }
    246          

   \                                 In section .text, align 2, keep-with-next
    247          bool nrf_hw_pwm::_is_enabled (uint8_t  pwm_index)
    248          {
    249            return _pwm_dev[pwm_index]->ENABLE;
   \                     _ZN10nrf_hw_pwm11_is_enabledEh: (+1)
   \        0x0   0x....'....        LDR.W    R2,??DataTable17_3
   \        0x4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x6   0xF852 0x1021      LDR      R1,[R2, R1, LSL #+2]
   \        0xA   0xF8D1 0x1500      LDR      R1,[R1, #+1280]
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD001             BEQ.N    ??_is_enabled_0
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xE000             B.N      ??_is_enabled_1
   \                     ??_is_enabled_0: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   \                     ??_is_enabled_1: (+1)
   \       0x18   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x1A   0x4770             BX       LR               ;; return
    250          }
    251          

   \                                 In section .text, align 2, keep-with-next
    252          void nrf_hw_pwm::start(uint8_t  pwm_index)
    253          {
   \                     _ZN10nrf_hw_pwm5startEh: (+1)
   \        0x0   0xB410             PUSH     {R4}
    254              _pwm_dev[pwm_index]->ENABLE  = (PWM_ENABLE_ENABLE_Enabled << PWM_ENABLE_ENABLE_Pos);
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x....'....        LDR.W    R3,??DataTable17_3
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \        0xC   0xF853 0x3024      LDR      R3,[R3, R4, LSL #+2]
   \       0x10   0xF8C3 0x2500      STR      R2,[R3, #+1280]
    255          }
   \       0x14   0xBC10             POP      {R4}
   \       0x16   0x4770             BX       LR               ;; return
    256          

   \                                 In section .text, align 2, keep-with-next
    257          void nrf_hw_pwm::stop(uint8_t  pwm_index)
    258          { 
   \                     _ZN10nrf_hw_pwm4stopEh: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    259              // переводим все ножки этого модуля в режим низкого энергопотребления
    260              for (uint8_t i = 0; i < LEDS_NUM; i++)
   \        0x6   0x2600             MOVS     R6,#+0
   \                     ??stop_0: (+1)
   \        0x8   0x0030             MOVS     R0,R6
   \        0xA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0xC   0x2808             CMP      R0,#+8
   \        0xE   0xDA1F             BGE.N    ??stop_1
    261              {
    262                  if (_pin_allocation_map[i][PWM_NUM] == pwm_index) 
   \       0x10   0x....'....        LDR.W    R1,??DataTable17_1
   \       0x14   0x0032             MOVS     R2,R6
   \       0x16   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x18   0x2006             MOVS     R0,#+6
   \       0x1A   0x4342             MULS     R2,R0,R2
   \       0x1C   0xEB01 0x0002      ADD      R0,R1,R2
   \       0x20   0xF9B0 0x0004      LDRSH    R0,[R0, #+4]
   \       0x24   0x0029             MOVS     R1,R5
   \       0x26   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x28   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \       0x2A   0x4288             CMP      R0,R1
   \       0x2C   0xD10E             BNE.N    ??stop_2
    263                  {          
    264                      nrf_gpio_cfg(led_2_port_list[i],
    265                                       NRF_GPIO_PIN_DIR_INPUT,
    266                                       NRF_GPIO_PIN_INPUT_DISCONNECT,
    267                                       NRF_GPIO_PIN_NOPULL,
    268                                       NRF_GPIO_PIN_S0S1,
    269                                       NRF_GPIO_PIN_NOSENSE);
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x9001             STR      R0,[SP, #+4]
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x9000             STR      R0,[SP, #+0]
   \       0x36   0x2300             MOVS     R3,#+0
   \       0x38   0x2201             MOVS     R2,#+1
   \       0x3A   0x2100             MOVS     R1,#+0
   \       0x3C   0x....'....        LDR.W    R0,??DataTable17_4
   \       0x40   0x0037             MOVS     R7,R6
   \       0x42   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \       0x44   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \       0x48   0x....'....        BL       _ZN36_INTERNAL_14_nrf_hw_pwm_cpp_e85aaef512nrf_gpio_cfgEj18nrf_gpio_pin_dir_t20nrf_gpio_pin_input_t19nrf_gpio_pin_pull_t20nrf_gpio_pin_drive_t20nrf_gpio_pin_sense_t
    270                  }
    271              }
   \                     ??stop_2: (+1)
   \       0x4C   0x1C76             ADDS     R6,R6,#+1
   \       0x4E   0xE7DB             B.N      ??stop_0
    272              
    273              // останавливаем только если модуль был активирован, потому что
    274              // иначе просто зависнет на while, поскольку TASKS_STOP не работает
    275              // если модуль не активен.
    276              if(_is_enabled(pwm_index))
   \                     ??stop_1: (+1)
   \       0x50   0x0029             MOVS     R1,R5
   \       0x52   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x54   0x0020             MOVS     R0,R4
   \       0x56   0x....'....        BL       _ZN10nrf_hw_pwm11_is_enabledEh
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD00F             BEQ.N    ??stop_3
    277              {
    278                  _pwm_dev[pwm_index]->TASKS_STOP = 1;
   \       0x5E   0x....'....        LDR.W    R1,??DataTable17_3
   \       0x62   0x2001             MOVS     R0,#+1
   \       0x64   0x002A             MOVS     R2,R5
   \       0x66   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x68   0xF851 0x2022      LDR      R2,[R1, R2, LSL #+2]
   \       0x6C   0x6050             STR      R0,[R2, #+4]
    279                  
    280                  while(!_pwm_dev[pwm_index]->EVENTS_STOPPED);
   \                     ??stop_4: (+1)
   \       0x6E   0x0028             MOVS     R0,R5
   \       0x70   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x72   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \       0x76   0xF8D0 0x0104      LDR      R0,[R0, #+260]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD0F7             BEQ.N    ??stop_4
    281              }
    282                      
    283              for(uint8_t i = 0; i < MAX_CHANNELS; i++)
   \                     ??stop_3: (+1)
   \       0x7E   0x2000             MOVS     R0,#+0
   \                     ??stop_5: (+1)
   \       0x80   0x0001             MOVS     R1,R0
   \       0x82   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x84   0x2904             CMP      R1,#+4
   \       0x86   0xDA1C             BGE.N    ??stop_6
    284              {
    285                  if(_pwm_dev[pwm_index]->PSEL.OUT[i] != PIN_DISCONNECTED)
   \       0x88   0x....'....        LDR.W    R1,??DataTable17_3
   \       0x8C   0x002A             MOVS     R2,R5
   \       0x8E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x90   0xF851 0x2022      LDR      R2,[R1, R2, LSL #+2]
   \       0x94   0x0003             MOVS     R3,R0
   \       0x96   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0x98   0xEB02 0x0283      ADD      R2,R2,R3, LSL #+2
   \       0x9C   0xF8D2 0x2560      LDR      R2,[R2, #+1376]
   \       0xA0   0xF112 0x0F01      CMN      R2,#+1
   \       0xA4   0xD00B             BEQ.N    ??stop_7
    286                  { _pwm_dev[pwm_index]->PSEL.OUT[i] = PIN_DISCONNECTED; }     
   \       0xA6   0x002A             MOVS     R2,R5
   \       0xA8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0xAA   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   \       0xAE   0x0002             MOVS     R2,R0
   \       0xB0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0xB2   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   \       0xB6   0xF05F 0x32FF      MOVS     R2,#-1
   \       0xBA   0xF8C1 0x2560      STR      R2,[R1, #+1376]
    287              }
   \                     ??stop_7: (+1)
   \       0xBE   0x1C40             ADDS     R0,R0,#+1
   \       0xC0   0xE7DE             B.N      ??stop_5
    288              
    289              // только после всего выключаем сам модуль, такие вот грабли.    
    290              _pwm_dev[pwm_index]->ENABLE = 0;
   \                     ??stop_6: (+1)
   \       0xC2   0x2000             MOVS     R0,#+0
   \       0xC4   0x....             LDR.N    R1,??DataTable17_3
   \       0xC6   0x002A             MOVS     R2,R5
   \       0xC8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0xCA   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   \       0xCE   0xF8C1 0x0500      STR      R0,[R1, #+1280]
    291          }
   \       0xD2   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    292          

   \                                 In section .text, align 2, keep-with-next
    293          void nrf_hw_pwm::_setup(uint8_t pwm_index)
    294          {
   \                     _ZN10nrf_hw_pwm6_setupEh: (+1)
   \        0x0   0xB410             PUSH     {R4}
    295              // Initialize Registers
    296              _pwm_dev[pwm_index]->MODE            = PWM_MODE_UPDOWN_UpAndDown;
   \        0x2   0x....             LDR.N    R2,??DataTable17_3
   \        0x4   0x2301             MOVS     R3,#+1
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \        0xA   0xF852 0x4024      LDR      R4,[R2, R4, LSL #+2]
   \        0xE   0xF8C4 0x3504      STR      R3,[R4, #+1284]
    297              _pwm_dev[pwm_index]->PRESCALER       = (uint32_t)_clock_div;
   \       0x12   0x7883             LDRB     R3,[R0, #+2]
   \       0x14   0x000C             MOVS     R4,R1
   \       0x16   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x18   0xF852 0x4024      LDR      R4,[R2, R4, LSL #+2]
   \       0x1C   0xF8C4 0x350C      STR      R3,[R4, #+1292]
    298              _pwm_dev[pwm_index]->DECODER         = (PWM_DECODER_LOAD_Individual << PWM_DECODER_LOAD_Pos) | 
    299                                                     (PWM_DECODER_MODE_RefreshCount << PWM_DECODER_MODE_Pos);
   \       0x20   0x2302             MOVS     R3,#+2
   \       0x22   0x000C             MOVS     R4,R1
   \       0x24   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x26   0xF852 0x4024      LDR      R4,[R2, R4, LSL #+2]
   \       0x2A   0xF8C4 0x3510      STR      R3,[R4, #+1296]
    300              _pwm_dev[pwm_index]->LOOP            = (PWM_LOOP_CNT_Disabled << PWM_LOOP_CNT_Pos);
   \       0x2E   0x2300             MOVS     R3,#+0
   \       0x30   0x000C             MOVS     R4,R1
   \       0x32   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x34   0xF852 0x4024      LDR      R4,[R2, R4, LSL #+2]
   \       0x38   0xF8C4 0x3514      STR      R3,[R4, #+1300]
    301              
    302              _pwm_dev[pwm_index]->SEQ[0].PTR      = (uint32_t) &_seq_0[pwm_index];
   \       0x3C   0x....             LDR.N    R3,??DataTable17_2
   \       0x3E   0x000C             MOVS     R4,R1
   \       0x40   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x42   0xEB03 0x03C4      ADD      R3,R3,R4, LSL #+3
   \       0x46   0x000C             MOVS     R4,R1
   \       0x48   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x4A   0xF852 0x4024      LDR      R4,[R2, R4, LSL #+2]
   \       0x4E   0xF8C4 0x3520      STR      R3,[R4, #+1312]
    303              _pwm_dev[pwm_index]->SEQ[0].CNT      = MAX_CHANNELS; // default mode is Individual --> count must be 4
   \       0x52   0x2304             MOVS     R3,#+4
   \       0x54   0x000C             MOVS     R4,R1
   \       0x56   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x58   0xF852 0x4024      LDR      R4,[R2, R4, LSL #+2]
   \       0x5C   0xF8C4 0x3524      STR      R3,[R4, #+1316]
    304              _pwm_dev[pwm_index]->SEQ[0].REFRESH  = 0;
   \       0x60   0x2300             MOVS     R3,#+0
   \       0x62   0x000C             MOVS     R4,R1
   \       0x64   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x66   0xF852 0x4024      LDR      R4,[R2, R4, LSL #+2]
   \       0x6A   0xF8C4 0x3528      STR      R3,[R4, #+1320]
    305              _pwm_dev[pwm_index]->SEQ[0].ENDDELAY = 0;
   \       0x6E   0x2300             MOVS     R3,#+0
   \       0x70   0x000C             MOVS     R4,R1
   \       0x72   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x74   0xF852 0x4024      LDR      R4,[R2, R4, LSL #+2]
   \       0x78   0xF8C4 0x352C      STR      R3,[R4, #+1324]
    306              
    307              _pwm_dev[pwm_index]->SEQ[1].PTR      = 0;
   \       0x7C   0x2300             MOVS     R3,#+0
   \       0x7E   0x000C             MOVS     R4,R1
   \       0x80   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x82   0xF852 0x4024      LDR      R4,[R2, R4, LSL #+2]
   \       0x86   0xF8C4 0x3540      STR      R3,[R4, #+1344]
    308              _pwm_dev[pwm_index]->SEQ[1].CNT      = 0;
   \       0x8A   0x2300             MOVS     R3,#+0
   \       0x8C   0x000C             MOVS     R4,R1
   \       0x8E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x90   0xF852 0x4024      LDR      R4,[R2, R4, LSL #+2]
   \       0x94   0xF8C4 0x3544      STR      R3,[R4, #+1348]
    309              _pwm_dev[pwm_index]->SEQ[1].REFRESH  = 0;
   \       0x98   0x2300             MOVS     R3,#+0
   \       0x9A   0x000C             MOVS     R4,R1
   \       0x9C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x9E   0xF852 0x4024      LDR      R4,[R2, R4, LSL #+2]
   \       0xA2   0xF8C4 0x3548      STR      R3,[R4, #+1352]
    310              _pwm_dev[pwm_index]->SEQ[1].ENDDELAY = 0;
   \       0xA6   0x2300             MOVS     R3,#+0
   \       0xA8   0x000C             MOVS     R4,R1
   \       0xAA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0xAC   0xF852 0x2024      LDR      R2,[R2, R4, LSL #+2]
   \       0xB0   0xF8C2 0x354C      STR      R3,[R2, #+1356]
    311          }   
   \       0xB4   0xBC10             POP      {R4}
   \       0xB6   0x4770             BX       LR               ;; return
    312          

   \                                 In section .text, align 2, keep-with-next
    313          void nrf_hw_pwm::_run_sequence(uint8_t pwm_index)
    314          {    
   \                     _ZN10nrf_hw_pwm13_run_sequenceEh: (+1)
   \        0x0   0xB410             PUSH     {R4}
    315              // запускаем PWM
    316              _pwm_dev[pwm_index]->TASKS_SEQSTART[0] = 1;
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x....             LDR.N    R3,??DataTable17_3
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \        0xA   0xF853 0x3024      LDR      R3,[R3, R4, LSL #+2]
   \        0xE   0x609A             STR      R2,[R3, #+8]
    317          }
   \       0x10   0xBC10             POP      {R4}
   \       0x12   0x4770             BX       LR               ;; return
    318          

   \                                 In section .text, align 4
    319          inline int8_t nrf_hw_pwm::write_chnl(uint8_t led, uint32_t value, bool inverted)
    320          {
   \                     _ZN10nrf_hw_pwm10write_chnlEhjb: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    321              uint8_t pwm_index = STATE_NA;
   \        0xC   0xF04F 0x08FF      MOV      R8,#+255
    322            
    323              // неправильный светодиод
    324              if (led >= LEDS_NUM)
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x14   0x2808             CMP      R0,#+8
   \       0x16   0xDB02             BLT.N    ??write_chnl_1
    325              { return REMOVED; }
   \       0x18   0xF07F 0x0002      MVNS     R0,#+2
   \       0x1C   0xE037             B.N      ??write_chnl_2
    326          
    327              volatile int ch = (int)_led_2_channel(led);
   \                     ??write_chnl_1: (+1)
   \       0x1E   0x0029             MOVS     R1,R5
   \       0x20   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x....'....        BL       _ZN10nrf_hw_pwm14_led_2_channelEh
   \       0x28   0x9000             STR      R0,[SP, #+0]
    328          
    329              // неверный канал
    330              if (ch < 0)
   \       0x2A   0x9800             LDR      R0,[SP, #+0]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD502             BPL.N    ??write_chnl_3
    331              return (int16_t)ch;
   \       0x30   0x9800             LDR      R0,[SP, #+0]
   \       0x32   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \       0x34   0xE02B             B.N      ??write_chnl_2
    332          
    333              pwm_index = _pin_allocation_map[led][PWM_NUM];
   \                     ??write_chnl_3: (+1)
   \       0x36   0x4917             LDR.N    R1,??write_chnl_0
   \       0x38   0x002A             MOVS     R2,R5
   \       0x3A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x3C   0x2006             MOVS     R0,#+6
   \       0x3E   0x4342             MULS     R2,R0,R2
   \       0x40   0xEB01 0x0002      ADD      R0,R1,R2
   \       0x44   0xF8B0 0x9004      LDRH     R9,[R0, #+4]
    334          
    335              _seq_0[pwm_index][ch] = value | (inverted ? 0 : 1UL << 15);
   \       0x48   0x9900             LDR      R1,[SP, #+0]
   \       0x4A   0x0038             MOVS     R0,R7
   \       0x4C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD001             BEQ.N    ??write_chnl_4
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xE001             B.N      ??write_chnl_5
   \                     ??write_chnl_4: (+1)
   \       0x56   0xF44F 0x4000      MOV      R0,#+32768
   \                     ??write_chnl_5: (+1)
   \       0x5A   0x4A0F             LDR.N    R2,??write_chnl_0+0x4
   \       0x5C   0x464B             MOV      R3,R9
   \       0x5E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0x60   0xEB02 0x02C3      ADD      R2,R2,R3, LSL #+3
   \       0x64   0x4330             ORRS     R0,R0,R6
   \       0x66   0xF822 0x0011      STRH     R0,[R2, R1, LSL #+1]
    336          
    337              // Start PWM if not already
    338              if (!_is_enabled(pwm_index))  
   \       0x6A   0x4649             MOV      R1,R9
   \       0x6C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x6E   0x0020             MOVS     R0,R4
   \       0x70   0x....'....        BL       _ZN10nrf_hw_pwm11_is_enabledEh
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD104             BNE.N    ??write_chnl_6
    339              { start(pwm_index); }
   \       0x78   0x4649             MOV      R1,R9
   \       0x7A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x7C   0x0020             MOVS     R0,R4
   \       0x7E   0x....'....        BL       _ZN10nrf_hw_pwm5startEh
    340              
    341              _run_sequence(pwm_index);    
   \                     ??write_chnl_6: (+1)
   \       0x82   0x4649             MOV      R1,R9
   \       0x84   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x86   0x0020             MOVS     R0,R4
   \       0x88   0x....'....        BL       _ZN10nrf_hw_pwm13_run_sequenceEh
    342              
    343              return STATE_OK;
   \       0x8C   0x2001             MOVS     R0,#+1
   \                     ??write_chnl_2: (+1)
   \       0x8E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   \       0x92   0xBF00             Nop      
   \                     ??write_chnl_0:
   \       0x94   0x....'....        DC32     _ZN10nrf_hw_pwm19_pin_allocation_mapE
   \       0x98   0x....'....        DC32     _ZN10nrf_hw_pwm6_seq_0E
    344          }
    345          
    346          inline int8_t nrf_hw_pwm::write_pin(uint32_t pin, uint32_t value, bool inverted)
    347          {
    348              volatile int16_t led = _pin_2_led(pin); 
    349              
    350              if(led < ALRDY_IS)
    351              { return REMOVED; }  
    352              
    353              write_chnl(led, value, inverted);
    354              
    355              return STATE_OK;
    356          }
    357          
    358          

   \                                 In section .text, align 2, keep-with-next
    359          int nrf_hw_pwm::read_pin(uint32_t pin)
    360          {
   \                     _ZN10nrf_hw_pwm8read_pinEj: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    361              volatile int16_t led = _pin_2_led(pin); 
   \        0x6   0x0029             MOVS     R1,R5
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x....'....        BL       _ZN10nrf_hw_pwm10_pin_2_ledEj
   \        0xE   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    362              
    363              if(led < ALRDY_IS)
   \       0x12   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD502             BPL.N    ??read_pin_0
    364              { return REMOVED; }
   \       0x1A   0xF07F 0x0002      MVNS     R0,#+2
   \       0x1E   0xE006             B.N      ??read_pin_1
    365                  
    366              return read_chnl(led);
   \                     ??read_pin_0: (+1)
   \       0x20   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x24   0x0001             MOVS     R1,R0
   \       0x26   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x....'....        BL       _ZN10nrf_hw_pwm9read_chnlEh
   \                     ??read_pin_1: (+1)
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    367          }
    368          

   \                                 In section .text, align 2, keep-with-next
    369          int nrf_hw_pwm::read_chnl(uint8_t led)
    370          {
   \                     _ZN10nrf_hw_pwm9read_chnlEh: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    371              int8_t pwm_index = STATE_NA;
   \        0x6   0xF05F 0x36FF      MOVS     R6,#-1
    372              
    373              // неправильный светодиод
    374              if (led >= LEDS_NUM)
   \        0xA   0x0028             MOVS     R0,R5
   \        0xC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0xE   0x2808             CMP      R0,#+8
   \       0x10   0xDB02             BLT.N    ??read_chnl_0
    375              { return REMOVED; }
   \       0x12   0xF07F 0x0002      MVNS     R0,#+2
   \       0x16   0xE01D             B.N      ??read_chnl_1
    376          
    377              volatile int ch = (int)_led_2_channel(led);
   \                     ??read_chnl_0: (+1)
   \       0x18   0x0029             MOVS     R1,R5
   \       0x1A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x....'....        BL       _ZN10nrf_hw_pwm14_led_2_channelEh
   \       0x22   0x9000             STR      R0,[SP, #+0]
    378          
    379              // неверный канал
    380              if (ch < 0)
   \       0x24   0x9800             LDR      R0,[SP, #+0]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD503             BPL.N    ??read_chnl_2
    381              return (int16_t)ch;
   \       0x2A   0x4668             MOV      R0,SP
   \       0x2C   0x6800             LDR      R0,[R0, #+0]
   \       0x2E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \       0x30   0xE010             B.N      ??read_chnl_1
    382          
    383              pwm_index = _pin_allocation_map[led][PWM_NUM];
   \                     ??read_chnl_2: (+1)
   \       0x32   0x....             LDR.N    R1,??DataTable17_1
   \       0x34   0x002A             MOVS     R2,R5
   \       0x36   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x38   0x2006             MOVS     R0,#+6
   \       0x3A   0x4342             MULS     R2,R0,R2
   \       0x3C   0xEB01 0x0002      ADD      R0,R1,R2
   \       0x40   0x8880             LDRH     R0,[R0, #+4]
    384          
    385              return (_seq_0[pwm_index][ch] & 0x7FFF);
   \       0x42   0x....             LDR.N    R1,??DataTable17_2
   \       0x44   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \       0x46   0xEB01 0x00C0      ADD      R0,R1,R0, LSL #+3
   \       0x4A   0x9900             LDR      R1,[SP, #+0]
   \       0x4C   0xF830 0x0011      LDRH     R0,[R0, R1, LSL #+1]
   \       0x50   0x0440             LSLS     R0,R0,#+17       ;; ZeroExtS R0,R0,#+17,#+17
   \       0x52   0x0C40             LSRS     R0,R0,#+17
   \                     ??read_chnl_1: (+1)
   \       0x54   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    386          }
    387          

   \                                 In section .text, align 2, keep-with-next
    388          int nrf_hw_pwm::get_channel(uint32_t pin)
    389          {
   \                     _ZN10nrf_hw_pwm11get_channelEj: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    390              volatile int16_t led = _pin_2_led(pin); 
   \        0x6   0x0029             MOVS     R1,R5
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x....'....        BL       _ZN10nrf_hw_pwm10_pin_2_ledEj
   \        0xE   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    391              
    392              if(led < ALRDY_IS)
   \       0x12   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD502             BPL.N    ??get_channel_0
    393              { return REMOVED; }  
   \       0x1A   0xF07F 0x0002      MVNS     R0,#+2
   \       0x1E   0xE008             B.N      ??get_channel_1
    394              
    395              return _pin_allocation_map[led][CHN_NUM];
   \                     ??get_channel_0: (+1)
   \       0x20   0x....             LDR.N    R0,??DataTable17_1
   \       0x22   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \       0x26   0x2206             MOVS     R2,#+6
   \       0x28   0xFB11 0xF102      SMULBB   R1,R1,R2
   \       0x2C   0x4408             ADD      R0,R0,R1
   \       0x2E   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \                     ??get_channel_1: (+1)
   \       0x32   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    396          }
    397          

   \                                 In section .text, align 2, keep-with-next
    398          int nrf_hw_pwm::get_pwm_num(uint32_t pin)
    399          {
   \                     _ZN10nrf_hw_pwm11get_pwm_numEj: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    400              volatile int16_t led = _pin_2_led(pin); 
   \        0x6   0x0029             MOVS     R1,R5
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x....'....        BL       _ZN10nrf_hw_pwm10_pin_2_ledEj
   \        0xE   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    401              
    402              if(led < ALRDY_IS)
   \       0x12   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD502             BPL.N    ??get_pwm_num_0
    403              { return REMOVED; }  
   \       0x1A   0xF07F 0x0002      MVNS     R0,#+2
   \       0x1E   0xE008             B.N      ??get_pwm_num_1
    404              
    405              return _pin_allocation_map[led][PWM_NUM];
   \                     ??get_pwm_num_0: (+1)
   \       0x20   0x....             LDR.N    R0,??DataTable17_1
   \       0x22   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \       0x26   0x2206             MOVS     R2,#+6
   \       0x28   0xFB11 0xF102      SMULBB   R1,R1,R2
   \       0x2C   0x4408             ADD      R0,R0,R1
   \       0x2E   0xF9B0 0x0004      LDRSH    R0,[R0, #+4]
   \                     ??get_pwm_num_1: (+1)
   \       0x32   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    406          }
    407          

   \                                 In section .text, align 2, keep-with-next
    408          int nrf_hw_pwm::get_led_num(uint32_t pin)
    409          {
   \                     _ZN10nrf_hw_pwm11get_led_numEj: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    410              volatile int16_t led = _pin_2_led(pin); 
   \        0x6   0x0029             MOVS     R1,R5
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x....'....        BL       _ZN10nrf_hw_pwm10_pin_2_ledEj
   \        0xE   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    411              
    412              if(led < ALRDY_IS)
   \       0x12   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD502             BPL.N    ??get_led_num_0
    413              { return REMOVED; }  
   \       0x1A   0xF07F 0x0002      MVNS     R0,#+2
   \       0x1E   0xE001             B.N      ??get_led_num_1
    414              
    415              return led;
   \                     ??get_led_num_0: (+1)
   \       0x20   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \                     ??get_led_num_1: (+1)
   \       0x24   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    416          }
    417          
    418          #ifdef THREE_PIN_CHARGE_BAR

   \                                 In section .text, align 2, keep-with-next
    419          void nrf_hw_pwm::set_chrg_bar(int16_t led_num)
    420          {
   \                     _ZN10nrf_hw_pwm12set_chrg_barEs: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    421              // не управляем ни чем если пины удалены.
    422              if (_chctrl_1 == REMOVED ||
    423                  _chctrl_2 == REMOVED || 
    424                  _chctrl_3 == REMOVED)
   \        0x6   0xF07F 0x0002      MVNS     R0,#+2
   \        0xA   0xF9B4 0x1004      LDRSH    R1,[R4, #+4]
   \        0xE   0x4281             CMP      R1,R0
   \       0x10   0xD008             BEQ.N    ??set_chrg_bar_0
   \       0x12   0xF9B4 0x1006      LDRSH    R1,[R4, #+6]
   \       0x16   0x4281             CMP      R1,R0
   \       0x18   0xD004             BEQ.N    ??set_chrg_bar_0
   \       0x1A   0xF9B4 0x0008      LDRSH    R0,[R4, #+8]
   \       0x1E   0xF110 0x0F03      CMN      R0,#+3
   \       0x22   0xD100             BNE.N    ??set_chrg_bar_1
    425              { return; }
   \                     ??set_chrg_bar_0: (+1)
   \       0x24   0xE090             B.N      ??set_chrg_bar_2
    426          
    427              // чтобы не моргало.
    428              if (_old_chrg_bar_state != led_num)
   \                     ??set_chrg_bar_1: (+1)
   \       0x26   0x....             LDR.N    R6,??DataTable17_5
   \       0x28   0xF9B6 0x0000      LDRSH    R0,[R6, #+0]
   \       0x2C   0x0029             MOVS     R1,R5
   \       0x2E   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \       0x30   0x4288             CMP      R0,R1
   \       0x32   0xF000 0x8089      BEQ.W    ??set_chrg_bar_3
    429              {
    430                  switch(led_num)
   \       0x36   0x0028             MOVS     R0,R5
   \       0x38   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD006             BEQ.N    ??set_chrg_bar_4
   \       0x3E   0x2802             CMP      R0,#+2
   \       0x40   0xD01E             BEQ.N    ??set_chrg_bar_5
   \       0x42   0xD30C             BCC.N    ??set_chrg_bar_6
   \       0x44   0x2804             CMP      R0,#+4
   \       0x46   0xD04D             BEQ.N    ??set_chrg_bar_7
   \       0x48   0xD333             BCC.N    ??set_chrg_bar_8
   \       0x4A   0xE064             B.N      ??set_chrg_bar_9
    431                  {
    432                      case CHRG_LED1:
    433                          write_chnl(_chctrl_2, 220, true);
   \                     ??set_chrg_bar_4: (+1)
   \       0x4C   0x2301             MOVS     R3,#+1
   \       0x4E   0x22DC             MOVS     R2,#+220
   \       0x50   0x88E0             LDRH     R0,[R4, #+6]
   \       0x52   0x0001             MOVS     R1,R0
   \       0x54   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x56   0x0020             MOVS     R0,R4
   \       0x58   0x....'....        BL       _ZN10nrf_hw_pwm10write_chnlEhjb
    434                          break;
   \       0x5C   0xE073             B.N      ??set_chrg_bar_10
    435              
    436                      case CHRG_LED2:
    437                          write_chnl(_chctrl_2, 220, true);
   \                     ??set_chrg_bar_6: (+1)
   \       0x5E   0x2301             MOVS     R3,#+1
   \       0x60   0x22DC             MOVS     R2,#+220
   \       0x62   0x88E0             LDRH     R0,[R4, #+6]
   \       0x64   0x0001             MOVS     R1,R0
   \       0x66   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x68   0x0020             MOVS     R0,R4
   \       0x6A   0x....'....        BL       _ZN10nrf_hw_pwm10write_chnlEhjb
    438                          write_chnl(_chctrl_1, 220, true);
   \       0x6E   0x2301             MOVS     R3,#+1
   \       0x70   0x22DC             MOVS     R2,#+220
   \       0x72   0x88A0             LDRH     R0,[R4, #+4]
   \       0x74   0x0001             MOVS     R1,R0
   \       0x76   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x78   0x0020             MOVS     R0,R4
   \       0x7A   0x....'....        BL       _ZN10nrf_hw_pwm10write_chnlEhjb
    439                          break;
   \       0x7E   0xE062             B.N      ??set_chrg_bar_10
    440              
    441                      case CHRG_LED3:
    442                          write_chnl(_chctrl_2, 220, true);
   \                     ??set_chrg_bar_5: (+1)
   \       0x80   0x2301             MOVS     R3,#+1
   \       0x82   0x22DC             MOVS     R2,#+220
   \       0x84   0x88E0             LDRH     R0,[R4, #+6]
   \       0x86   0x0001             MOVS     R1,R0
   \       0x88   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x8A   0x0020             MOVS     R0,R4
   \       0x8C   0x....'....        BL       _ZN10nrf_hw_pwm10write_chnlEhjb
    443                          write_chnl(_chctrl_1, 220, true);
   \       0x90   0x2301             MOVS     R3,#+1
   \       0x92   0x22DC             MOVS     R2,#+220
   \       0x94   0x88A0             LDRH     R0,[R4, #+4]
   \       0x96   0x0001             MOVS     R1,R0
   \       0x98   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x9A   0x0020             MOVS     R0,R4
   \       0x9C   0x....'....        BL       _ZN10nrf_hw_pwm10write_chnlEhjb
    444                          write_chnl(_chctrl_3,        32);
   \       0xA0   0x2300             MOVS     R3,#+0
   \       0xA2   0x2220             MOVS     R2,#+32
   \       0xA4   0x8920             LDRH     R0,[R4, #+8]
   \       0xA6   0x0001             MOVS     R1,R0
   \       0xA8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0xAA   0x0020             MOVS     R0,R4
   \       0xAC   0x....'....        BL       _ZN10nrf_hw_pwm10write_chnlEhjb
    445                          break;
   \       0xB0   0xE049             B.N      ??set_chrg_bar_10
    446              
    447                      case CHRG_LED4:
    448                          write_chnl(_chctrl_2, 220, true);
   \                     ??set_chrg_bar_8: (+1)
   \       0xB2   0x2301             MOVS     R3,#+1
   \       0xB4   0x22DC             MOVS     R2,#+220
   \       0xB6   0x88E0             LDRH     R0,[R4, #+6]
   \       0xB8   0x0001             MOVS     R1,R0
   \       0xBA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0xBC   0x0020             MOVS     R0,R4
   \       0xBE   0x....'....        BL       _ZN10nrf_hw_pwm10write_chnlEhjb
    449                          write_chnl(_chctrl_1,   0, true);
   \       0xC2   0x2301             MOVS     R3,#+1
   \       0xC4   0x2200             MOVS     R2,#+0
   \       0xC6   0x88A0             LDRH     R0,[R4, #+4]
   \       0xC8   0x0001             MOVS     R1,R0
   \       0xCA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0xCC   0x0020             MOVS     R0,R4
   \       0xCE   0x....'....        BL       _ZN10nrf_hw_pwm10write_chnlEhjb
    450                          write_chnl(_chctrl_3,        32);
   \       0xD2   0x2300             MOVS     R3,#+0
   \       0xD4   0x2220             MOVS     R2,#+32
   \       0xD6   0x8920             LDRH     R0,[R4, #+8]
   \       0xD8   0x0001             MOVS     R1,R0
   \       0xDA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0xDC   0x0020             MOVS     R0,R4
   \       0xDE   0x....'....        BL       _ZN10nrf_hw_pwm10write_chnlEhjb
    451                          break;
   \       0xE2   0xE030             B.N      ??set_chrg_bar_10
    452              
    453                      case CHRG_LED5:
    454                          write_chnl(_chctrl_2, 32);
   \                     ??set_chrg_bar_7: (+1)
   \       0xE4   0x2300             MOVS     R3,#+0
   \       0xE6   0x2220             MOVS     R2,#+32
   \       0xE8   0x88E0             LDRH     R0,[R4, #+6]
   \       0xEA   0x0001             MOVS     R1,R0
   \       0xEC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0xEE   0x0020             MOVS     R0,R4
   \       0xF0   0x....'....        BL       _ZN10nrf_hw_pwm10write_chnlEhjb
    455                          write_chnl(_chctrl_1, 32);
   \       0xF4   0x2300             MOVS     R3,#+0
   \       0xF6   0x2220             MOVS     R2,#+32
   \       0xF8   0x88A0             LDRH     R0,[R4, #+4]
   \       0xFA   0x0001             MOVS     R1,R0
   \       0xFC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0xFE   0x0020             MOVS     R0,R4
   \      0x100   0x....'....        BL       _ZN10nrf_hw_pwm10write_chnlEhjb
    456                          write_chnl(_chctrl_3, 45);
   \      0x104   0x2300             MOVS     R3,#+0
   \      0x106   0x222D             MOVS     R2,#+45
   \      0x108   0x8920             LDRH     R0,[R4, #+8]
   \      0x10A   0x0001             MOVS     R1,R0
   \      0x10C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x10E   0x0020             MOVS     R0,R4
   \      0x110   0x....'....        BL       _ZN10nrf_hw_pwm10write_chnlEhjb
    457                          break;
   \      0x114   0xE017             B.N      ??set_chrg_bar_10
    458                          
    459                      case SHTDWN:
    460                      default:
    461                          write_chnl(_chctrl_2, 0);
   \                     ??set_chrg_bar_9: (+1)
   \      0x116   0x2300             MOVS     R3,#+0
   \      0x118   0x2200             MOVS     R2,#+0
   \      0x11A   0x88E0             LDRH     R0,[R4, #+6]
   \      0x11C   0x0001             MOVS     R1,R0
   \      0x11E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x120   0x0020             MOVS     R0,R4
   \      0x122   0x....'....        BL       _ZN10nrf_hw_pwm10write_chnlEhjb
    462                          write_chnl(_chctrl_1, 0);
   \      0x126   0x2300             MOVS     R3,#+0
   \      0x128   0x2200             MOVS     R2,#+0
   \      0x12A   0x88A0             LDRH     R0,[R4, #+4]
   \      0x12C   0x0001             MOVS     R1,R0
   \      0x12E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x130   0x0020             MOVS     R0,R4
   \      0x132   0x....'....        BL       _ZN10nrf_hw_pwm10write_chnlEhjb
    463                          write_chnl(_chctrl_3, 0);
   \      0x136   0x2300             MOVS     R3,#+0
   \      0x138   0x2200             MOVS     R2,#+0
   \      0x13A   0x8920             LDRH     R0,[R4, #+8]
   \      0x13C   0x0001             MOVS     R1,R0
   \      0x13E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \      0x140   0x0020             MOVS     R0,R4
   \      0x142   0x....'....        BL       _ZN10nrf_hw_pwm10write_chnlEhjb
    464                          break;
    465                  }
    466              
    467                  _old_chrg_bar_state = led_num;
   \                     ??set_chrg_bar_10: (+1)
   \      0x146   0x8035             STRH     R5,[R6, #+0]
    468          
    469              }
    470          }
   \                     ??set_chrg_bar_3: (+1)
   \                     ??set_chrg_bar_2: (+1)
   \      0x148   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x5000'0300        DC32     0x50000300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \        0x0   0x....'....        DC32     _ZN10nrf_hw_pwm19_pin_allocation_mapE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \        0x0   0x....'....        DC32     _ZN10nrf_hw_pwm6_seq_0E

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \        0x0   0x....'....        DC32     _ZN10nrf_hw_pwm8_pwm_devE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \        0x0   0x....'....        DC32     led_2_port_list

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \        0x0   0x....'....        DC32     _ZN10nrf_hw_pwm19_old_chrg_bar_stateE
    471          #endif // THREE_PIN_CHARGE_BAR
    472          
    473          
    474          
    475          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   nrf_gpio_cfg(uint32_t, nrf_gpio_pin_dir_t, nrf_gpio_pin_input_t, nrf_gpio_pin_pull_t, nrf_gpio_pin_drive_t, nrf_gpio_pin_sense_t)
        32   -> nrf_gpio_pin_port_decode(uint32_t *)
      16   nrf_gpio_cfg_output(uint32_t)
        16   -> nrf_gpio_cfg(uint32_t, nrf_gpio_pin_dir_t, nrf_gpio_pin_input_t, nrf_gpio_pin_pull_t, nrf_gpio_pin_drive_t, nrf_gpio_pin_sense_t)
       0   nrf_gpio_pin_port_decode(uint32_t *)
       0   nrf_hw_pwm::_is_enabled(uint8_t)
       4   nrf_hw_pwm::_led_2_channel(uint8_t)
       8   nrf_hw_pwm::_pin_2_led(uint32_t)
       4   nrf_hw_pwm::_run_sequence(uint8_t)
       4   nrf_hw_pwm::_setup(uint8_t)
      32   nrf_hw_pwm::add_pin(uint32_t)
        32   -> nrf_gpio_cfg_output(uint32_t)
        32   -> nrf_hw_pwm::_is_enabled(uint8_t)
        32   -> nrf_hw_pwm::_pin_2_led(uint32_t)
        32   -> nrf_hw_pwm::write_chnl(uint8_t, uint32_t, bool)
      16   nrf_hw_pwm::get_channel(uint32_t)
        16   -> nrf_hw_pwm::_pin_2_led(uint32_t)
      16   nrf_hw_pwm::get_led_num(uint32_t)
        16   -> nrf_hw_pwm::_pin_2_led(uint32_t)
      16   nrf_hw_pwm::get_pwm_num(uint32_t)
        16   -> nrf_hw_pwm::_pin_2_led(uint32_t)
       0   nrf_hw_pwm::nrf_hw_pwm()
      24   nrf_hw_pwm::nrf_hw_pwm(uint16_t)
        24   -> __aeabi_memset
        24   -> nrf_hw_pwm::_setup(uint8_t)
        24   -> nrf_hw_pwm::set_clock_div(uint8_t)
        24   -> nrf_hw_pwm::set_max_value(uint8_t, uint32_t)
      40   nrf_hw_pwm::nrf_hw_pwm(uint16_t, uint32_t, uint32_t, uint32_t)
        40   -> __aeabi_memset
        40   -> nrf_hw_pwm::_pin_2_led(uint32_t)
        40   -> nrf_hw_pwm::_setup(uint8_t)
        40   -> nrf_hw_pwm::add_pin(uint32_t)
        40   -> nrf_hw_pwm::set_clock_div(uint8_t)
        40   -> nrf_hw_pwm::set_max_value(uint8_t, uint32_t)
      24   nrf_hw_pwm::read_chnl(uint8_t)
        24   -> nrf_hw_pwm::_led_2_channel(uint8_t)
      16   nrf_hw_pwm::read_pin(uint32_t)
        16   -> nrf_hw_pwm::_pin_2_led(uint32_t)
        16   -> nrf_hw_pwm::read_chnl(uint8_t)
      24   nrf_hw_pwm::remove_pin(uint8_t)
        24   -> nrf_hw_pwm::_is_enabled(uint8_t)
        24   -> nrf_hw_pwm::_led_2_channel(uint8_t)
      16   nrf_hw_pwm::set_chrg_bar(int16_t)
        16   -> nrf_hw_pwm::write_chnl(uint8_t, uint32_t, bool)
       0   nrf_hw_pwm::set_clock_div(uint8_t)
       4   nrf_hw_pwm::set_max_value(uint8_t, uint32_t)
       4   nrf_hw_pwm::start(uint8_t)
      32   nrf_hw_pwm::stop(uint8_t)
        32   -> nrf_gpio_cfg(uint32_t, nrf_gpio_pin_dir_t, nrf_gpio_pin_input_t, nrf_gpio_pin_pull_t, nrf_gpio_pin_drive_t, nrf_gpio_pin_sense_t)
        32   -> nrf_hw_pwm::_is_enabled(uint8_t)
       8   nrf_hw_pwm::subobject nrf_hw_pwm()
         8   -> nrf_hw_pwm::nrf_hw_pwm()
       8   nrf_hw_pwm::subobject nrf_hw_pwm(uint16_t)
         8   -> nrf_hw_pwm::nrf_hw_pwm(uint16_t)
      16   nrf_hw_pwm::subobject nrf_hw_pwm(uint16_t, uint32_t, uint32_t, uint32_t)
        16   -> nrf_hw_pwm::nrf_hw_pwm(uint16_t, uint32_t, uint32_t, uint32_t)
      32   nrf_hw_pwm::write_chnl(uint8_t, uint32_t, bool)
        32   -> nrf_hw_pwm::_is_enabled(uint8_t)
        32   -> nrf_hw_pwm::_led_2_channel(uint8_t)
        32   -> nrf_hw_pwm::_run_sequence(uint8_t)
        32   -> nrf_hw_pwm::start(uint8_t)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
      72  nrf_gpio_cfg(uint32_t, nrf_gpio_pin_dir_t, nrf_gpio_pin_input_t, nrf_gpio_pin_pull_t, nrf_gpio_pin_drive_t, nrf_gpio_pin_sense_t)
      26  nrf_gpio_cfg_output(uint32_t)
      28  nrf_gpio_pin_port_decode(uint32_t *)
      28  nrf_hw_pwm::_is_enabled(uint8_t)
      64  nrf_hw_pwm::_led_2_channel(uint8_t)
       2  nrf_hw_pwm::_old_chrg_bar_state
      50  nrf_hw_pwm::_pin_2_led(uint32_t)
      48  nrf_hw_pwm::_pin_allocation_map
      16  nrf_hw_pwm::_pwm_dev
      20  nrf_hw_pwm::_run_sequence(uint8_t)
      32  nrf_hw_pwm::_seq_0
     184  nrf_hw_pwm::_setup(uint8_t)
     326  nrf_hw_pwm::add_pin(uint32_t)
      52  nrf_hw_pwm::get_channel(uint32_t)
      38  nrf_hw_pwm::get_led_num(uint32_t)
      52  nrf_hw_pwm::get_pwm_num(uint32_t)
       2  nrf_hw_pwm::nrf_hw_pwm()
     152  nrf_hw_pwm::nrf_hw_pwm(uint16_t)
     218  nrf_hw_pwm::nrf_hw_pwm(uint16_t, uint32_t, uint32_t, uint32_t)
      86  nrf_hw_pwm::read_chnl(uint8_t)
      48  nrf_hw_pwm::read_pin(uint32_t)
     178  nrf_hw_pwm::remove_pin(uint8_t)
     330  nrf_hw_pwm::set_chrg_bar(int16_t)
      92  nrf_hw_pwm::set_clock_div(uint8_t)
      24  nrf_hw_pwm::set_max_value(uint8_t, uint32_t)
      24  nrf_hw_pwm::start(uint8_t)
     212  nrf_hw_pwm::stop(uint8_t)
      12  nrf_hw_pwm::subobject nrf_hw_pwm()
      14  nrf_hw_pwm::subobject nrf_hw_pwm(uint16_t)
      18  nrf_hw_pwm::subobject nrf_hw_pwm(uint16_t, uint32_t, uint32_t, uint32_t)
     156  nrf_hw_pwm::write_chnl(uint8_t, uint32_t, bool)

 
    80 bytes in section .bss
    18 bytes in section .data
 2'530 bytes in section .text
 
 2'374 bytes of CODE memory (+ 156 bytes shared)
    98 bytes of DATA memory

Errors: none
Warnings: none
